import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from monomode import a, NA, lambda_laser
import os


#path csv Alex
fichier_csv = r"C:\Users\alext\OneDrive\Bureau\Génie physique\Calculs python\Labos-TPOP\Labo2_Fibre\Values.1mode.csv"

#path csv Mathilde
#dossier_script = os.path.dirname(os.path.abspath(__file__))
#fichier_csv = os.path.join(dossier_script, "Values.1mode.csv")

#csv data
data = np.genfromtxt(fichier_csv, delimiter=",", names=True)

#extraire els données + normaliser
theta_diffraction = np.degrees(np.arcsin(1.220 * lambda_laser / (2*a)))
V = (2 * np.pi * a / lambda_laser) * NA
x = data['Distance']  
y = data['Intensite']  
y_norm = (y / np.max(y))
x_cent = x - 1789.03
x_theta = x_cent * theta_diffraction / (1789.03-65) #65 trouvé manuellement en regardant les donnes

#curve fit
def gaussian(x, amplitude, mean, std_dev, b):
    return amplitude * np.exp(-((x - mean) ** 2) / (2 * std_dev ** 2)) + b

# guess basées sur les données expérimentales pour x
initial_guesses = [max(y_norm) - min(y_norm), x[np.argmax(y_norm)], np.std(x), min(y_norm)]
# fit sur les données expérimentales pour y_norm
xx = np.linspace(min(x), max(x), 500)
popt, pcov = curve_fit(gaussian, x, y_norm, p0=initial_guesses)
fitted_amplitude, fitted_mean, fitted_std_dev, fitted_b = popt
#fitted curve x
y_fit = gaussian(xx, *popt)
#print(f"Fitted Parameters:   Amplitude={fitted_amplitude:.2f}, Mean={fitted_mean:.2f}, Std Dev={fitted_std_dev:.2f}, Baseline={fitted_b:.2f}")


# guess basées sur les données expérimentales pour x_cent
initial_guesses_cent = [max(y_norm) - min(y_norm), x[np.argmax(y_norm)], np.std(x_cent), min(y_norm)]
# fit sur les données expérimentales pour y_norm_cent
xx_cent = np.linspace(min(x_cent), max(x_cent), 500)
popt_cent, pcov_cent = curve_fit(gaussian, x_cent, y_norm, p0=initial_guesses_cent)
fitted_amplitude_cent , fitted_mean_cent, fitted_std_dev_cent, fitted_b_cent = popt
#fitted curve x_cent
y_fit_cent = gaussian(xx_cent , *popt_cent)
#print(f"Fitted Parameters:   Amplitude={fitted_amplitude_cent:.2f}, Mean={fitted_mean_cent:.2f}, Std Dev={fitted_std_dev_cent:.2f}, Baseline={fitted_b_cent:.2f}")


# guess basées sur les données expérimentales pour x_theta
initial_guesses_theta = [max(y_norm) - min(y_norm), x_theta[np.argmax(y_norm)], np.std(x_theta), min(y_norm)]
# fit sur les données expérimentales pour y_norm_cent
xx_theta = np.linspace(min(x_theta), max(x_theta), 500)
popt_theta, pcov_theta = curve_fit(gaussian, x_theta, y_norm, p0=initial_guesses_theta)
fitted_amplitude_theta , fitted_mean_theta, fitted_std_dev_theta, fitted_b_theta = popt_theta
#fitted curve x_cent
y_fit_theta = gaussian(xx_theta , *popt_theta)
print(f"Fitted Parameters:   Amplitude={fitted_amplitude_theta:.6f}, Mean={fitted_mean_theta:.6f}, Std Dev={fitted_std_dev_theta:.6f}, Baseline={fitted_b_theta:.6f}")
print(f'V = {V:.6f}')

#r carré
y_pred = gaussian(x_theta, *popt_theta)
residuals = y_norm - y_pred
ss_res = np.sum(residuals**2)
ss_tot = np.sum((y_norm - np.mean(y_norm))**2)
r2 = 1 - ss_res / ss_tot
print(f"R2 = {r2:.6f}")

#grohique
plt.figure()

#cent
#plt.plot(x_cent, y_norm, linestyle='-', linewidth=1, label='Données expérimentales', color="#898D8D")
#plt.plot(xx_cent, y_fit_cent, linestyle='--', linewidth=2, label='Approximation gaussienne', color="#343030")

#not cent
#plt.plot(x, y_norm, linestyle='-', linewidth=1, label='Données expérimentales', color="#898D8D")
#plt.plot(xx, y_fit, linestyle='--', linewidth=2, label='Approx gaussienne', color="#343030")

#theta_cent
plt.plot(x_theta, y_norm, linestyle='-', linewidth=1, label='Données expérimentales', color="#898D8D")
plt.plot(xx_theta, y_fit_theta, linestyle='--', linewidth=1.7, label='Approximation gaussienne', color="#181515")

#axes
plt.xlabel("Angle ($\degree$)", fontsize=20)
plt.ylabel("Intensité normalisée", fontsize=20)
plt.xticks(fontsize=18)
plt.yticks(fontsize=18)
plt.legend(fontsize=16)
plt.show()
