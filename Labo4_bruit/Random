import numpy as np
import matplotlib.pyplot as plt

# ===============================================
# CHARGEMENT DES DONNÉES
# ===============================================

# Charger les données depuis le fichier CSV
# Ajustez le nom du fichier selon votre cas
donnees = np.loadtxt('donnees.csv', delimiter=',', skiprows=1)

# Si votre CSV a plusieurs colonnes (temps, signal, sync, etc.)
# temps = donnees[:, 0]
# signal = donnees[:, 1]
# sync = donnees[:, 2]  # Signal de synchronisation

# Ou si vous avez seulement le signal:
signal = donnees

print(f"Nombre total de points: {len(signal)}")


# ===============================================
# QUESTION 4: DÉMONSTRATION DU SEM
# ===============================================

def calculer_sem_experimental(data, N_points, N_repetitions=1000):
    """
    Calcule l'erreur standard expérimentale en tirant aléatoirement
    N_points du jeu de données et en calculant leur moyenne.
    
    Paramètres:
    - data: tableau de données
    - N_points: nombre de points à tirer pour chaque moyenne
    - N_repetitions: nombre de fois qu'on répète le tirage
    
    Retourne:
    - moyennes: tableau des moyennes calculées
    - std_moyennes: écart-type des moyennes (SEM expérimental)
    """
    moyennes = np.zeros(N_repetitions)
    
    for i in range(N_repetitions):
        # Tirer N_points aléatoirement (avec remplacement)
        echantillon = np.random.choice(data, size=N_points, replace=True)
        moyennes[i] = np.mean(echantillon)
    
    std_moyennes = np.std(moyennes)
    
    return moyennes, std_moyennes


# ===============================================
# QUESTION 4a-b: Tirer 2 points aléatoirement
# ===============================================

# Utiliser uniquement les données "signal haut"
# (À adapter selon votre signal de synchronisation)
signal_haut = signal  # Remplacez par signal[sync > seuil] si nécessaire

N_repetitions = 10000
moyennes_N2, sem_N2 = calculer_sem_experimental(signal_haut, N_points=2, N_repetitions=N_repetitions)

print(f"\n--- Résultats pour N=2 points ---")
print(f"SEM expérimental: {sem_N2:.6f}")
print(f"SEM théorique: {np.std(signal_haut) / np.sqrt(2):.6f}")

# Visualiser la distribution des moyennes
plt.figure(figsize=(10, 5))
plt.hist(moyennes_N2, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.xlabel('Valeur de la moyenne')
plt.ylabel('Densité de probabilité')
plt.title(f'Distribution des moyennes (N=2 points, {N_repetitions} répétitions)')
plt.grid(True, alpha=0.3)
plt.show()


# ===============================================
# QUESTION 4c: Variation du SEM en fonction de N
# ===============================================

# Tester différentes valeurs de N
N_valeurs = [2, 5, 10, 20, 50, 100, 200, 500]
sem_experimental = []
sem_theorique = []

sigma = np.std(signal_haut)  # Écart-type de la population

for N in N_valeurs:
    _, sem_exp = calculer_sem_experimental(signal_haut, N_points=N, N_repetitions=1000)
    sem_experimental.append(sem_exp)
    sem_theorique.append(sigma / np.sqrt(N))
    print(f"N={N:4d} | SEM exp: {sem_exp:.6f} | SEM théo: {sigma / np.sqrt(N):.6f}")

# Tracer SEM vs N
plt.figure(figsize=(12, 5))

# Graphique 1: Échelle linéaire
plt.subplot(1, 2, 1)
plt.plot(N_valeurs, sem_experimental, 'o-', label='SEM expérimental', markersize=8)
plt.plot(N_valeurs, sem_theorique, 's--', label='SEM théorique (σ/√N)', markersize=6)
plt.xlabel('Nombre de points N')
plt.ylabel('SEM')
plt.title('Erreur standard de la moyenne vs N')
plt.legend()
plt.grid(True, alpha=0.3)

# Graphique 2: Échelle log-log pour vérifier la loi en puissance
plt.subplot(1, 2, 2)
plt.loglog(N_valeurs, sem_experimental, 'o-', label='SEM expérimental', markersize=8)
plt.loglog(N_valeurs, sem_theorique, 's--', label='SEM théorique (σ/√N)', markersize=6)
plt.xlabel('Nombre de points N')
plt.ylabel('SEM')
plt.title('SEM vs N (échelle log-log)')
plt.legend()
plt.grid(True, alpha=0.3, which='both')

plt.tight_layout()
plt.show()


# ===============================================
# VÉRIFICATION QUANTITATIVE: Ajustement en loi de puissance
# ===============================================

# On s'attend à SEM = A * N^(-0.5)
# En log: log(SEM) = log(A) - 0.5 * log(N)

log_N = np.log(N_valeurs)
log_SEM = np.log(sem_experimental)

# Régression linéaire
coefficients = np.polyfit(log_N, log_SEM, 1)
pente = coefficients[0]
ordonnee = coefficients[1]

print(f"\n--- Ajustement en loi de puissance ---")
print(f"SEM = A * N^(exposant)")
print(f"Exposant mesuré: {pente:.4f}")
print(f"Exposant théorique: -0.5")
print(f"Écart relatif: {abs(pente + 0.5) / 0.5 * 100:.2f}%")


# ===============================================
# EXEMPLE: Séparation signal haut / bruit de fond
# ===============================================

def separer_signal_sync(signal, sync, seuil=0.5):
    """
    Sépare le signal en deux parties selon le signal de synchronisation
    
    Paramètres:
    - signal: données du signal
    - sync: signal de synchronisation
    - seuil: valeur seuil pour différencier haut/bas
    
    Retourne:
    - signal_haut: données quand sync > seuil
    - bruit_fond: données quand sync <= seuil
    """
    indices_haut = np.where(sync > seuil)[0]
    indices_bas = np.where(sync <= seuil)[0]
    
    signal_haut = signal[indices_haut]
    bruit_fond = signal[indices_bas]
    
    return signal_haut, bruit_fond


# ===============================================
# CALCULS UTILES POUR LE LABO
# ===============================================

def calculer_snr(signal, bruit):
    """Calcule le SNR = μ_signal / σ_signal"""
    mu = np.mean(signal)
    sigma = np.std(signal)
    return mu / sigma

def calculer_augmentation_signal(signal_haut, bruit_fond):
    """
    Calcule l'augmentation du signal par rapport au bruit de fond
    avec incertitudes
    """
    mu_haut = np.mean(signal_haut)
    mu_fond = np.mean(bruit_fond)
    
    sem_haut = np.std(signal_haut) / np.sqrt(len(signal_haut))
    sem_fond = np.std(bruit_fond) / np.sqrt(len(bruit_fond))
    
    augmentation = mu_haut - mu_fond
    incertitude = np.sqrt(sem_haut**2 + sem_fond**2)
    
    print(f"\n--- Augmentation du signal ---")
    print(f"Signal haut: {mu_haut:.6f} ± {sem_haut:.6f}")
    print(f"Bruit de fond: {mu_fond:.6f} ± {sem_fond:.6f}")
    print(f"Augmentation: {augmentation:.6f} ± {incertitude:.6f}")
    
    return augmentation, incertitude


print("\n=== Analyse terminée ===")